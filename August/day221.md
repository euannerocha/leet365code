# Roet

Roet is a minimal JavaScript UI library inspired by React, created to explore the gaps and simplify the building of interactive web apps without build tools.

---

## ðŸ“œ Current Features

- **Virtual DOM** using `createElement` and `render`.
- **Functional Components** support.
- **Default Props** (`Component.defaultProps`).
- **Children** passed automatically to components.
- **Event handling** via direct DOM property assignment.

---

## Virtual DOM Creation

The `createElement` function is the core of Roet.  
It creates a lightweight **Virtual DOM node** that describes what should be rendered in the browser later.

```javascript
function createElement(type, props, ...children) {
  props = props || {};
  props.children = children.length > 0 ? children : null;
  return { type, props };
}


type: can be a string ('div') or a function (a component).

props: object containing element attributes and data.

children: nested elements or text inside the component.

___

# Rendering a Virtual DOM

The render function takes a Virtual DOM node and transforms it into a real DOM element in the browser.

function render(vnode, container) {
  if (typeof vnode === "string" || typeof vnode === "number") {
    container.appendChild(document.createTextNode(vnode));
    return;
  }

  if (typeof vnode.type === "function") {
    const defaultProps = vnode.type.defaultProps || {};
    const mergedProps = { ...defaultProps, ...vnode.props };
    render(vnode.type(mergedProps), container);
    return;
  }

  const dom = document.createElement(vnode.type);

  if (vnode.props) {
    Object.keys(vnode.props).forEach(prop => {
      if (prop !== "children") {
        dom[prop] = vnode.props[prop];
      }
    });
  }

  if (vnode.props && vnode.props.children) {
    vnode.props.children.forEach(child => render(child, dom));
  }

  container.appendChild(dom);
}

Strings & numbers are converted to text nodes.

Functions are treated as components and re-rendered.

Objects are transformed into HTML elements with properties.

---

# Functional Components

A functional component is a function that returns a Virtual DOM.
They make your UI reusable and easier to maintain.

function App() {
  return createElement('h1', null, 'Hello from Roet');
}
render(createElement(App, null), document.getElementById('root'));


---

# Default Props

If a component is used without all its props, defaultProps fill the missing ones.

function Button(props) {
  return createElement('button', { onclick: props.onClick }, props.label);
}
Button.defaultProps = {
  label: 'Click me',
  onClick: () => alert('Default click!')
};


---

# Children

In Roet, props.children automatically contains the content passed inside a component.

function Box(props) {
  return createElement(
    'div',
    { style: 'border: 1px solid black; padding: 10px;' },
    props.children
  );
}


---

# Full Example

Here is the full HTML file using Roet with all features above:

<!DOCTYPE html>
<html>
  <head>
    <title>Roet App</title>
  </head>
  <body>
    <div id="root"></div>
    <script>
      function createElement(type, props, ...children) {
        props = props || {};
        props.children = children.length > 0 ? children : null;
        return { type, props };
      }

      function render(vnode, container) {
        if (typeof vnode === "string" || typeof vnode === "number") {
          container.appendChild(document.createTextNode(vnode));
          return;
        }

        if (typeof vnode.type === "function") {
          const defaultProps = vnode.type.defaultProps || {};
          const mergedProps = { ...defaultProps, ...vnode.props };
          render(vnode.type(mergedProps), container);
          return;
        }

        const dom = document.createElement(vnode.type);

        if (vnode.props) {
          Object.keys(vnode.props).forEach(prop => {
            if (prop !== "children") {
              dom[prop] = vnode.props[prop];
            }
          });
        }

        if (vnode.props && vnode.props.children) {
          vnode.props.children.forEach(child => render(child, dom));
        }

        container.appendChild(dom);
      }

      function Button(props) {
        return createElement('button', { onclick: props.onClick }, props.label);
      }
      Button.defaultProps = {
        label: 'Click me',
        onClick: () => alert('Default click!')
      };

      function Box(props) {
        return createElement(
          'div',
          { style: 'border: 1px solid black; padding: 10px;' },
          props.children
        );
      }

      const App = () =>
        createElement(
          'div',
          null,
          createElement(Button, null),
          createElement(Box, null, 'Hello inside box!')
        );

      render(createElement(App, null), document.getElementById('root'));
    </script>
  </body>
</html>


---

ðŸš€ Roadmap

1. Class name & style normalization

Support className prop and style objects like React.



2. Synthetic Events System

Normalize event names and make them consistent across browsers.



3. Basic State Management (useState)

Allow reactive re-rendering on state changes.



4. Conditional Rendering

Add support for fragments and conditional rendering helpers.



5. JSX Support

Add a simple JSX transform to work with Babel or a custom parser.



6. Diffing & Efficient Updates

Implement a simple reconciliation algorithm to avoid full re-render.

